---
# PostgreSQL Configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: postgresql-config
  labels:
    app: cost-monitor
    component: database
data:
  postgresql.conf: |
    # Connection settings
    listen_addresses = '*'
    port = 5432
    max_connections = 200
    
    # Memory settings (adjust based on pod resources)
    shared_buffers = 512MB
    effective_cache_size = 1536MB
    work_mem = 16MB
    maintenance_work_mem = 256MB
    
    # WAL settings
    wal_level = replica
    max_wal_size = 2GB
    min_wal_size = 80MB
    checkpoint_completion_target = 0.7
    
    # Query tuning
    random_page_cost = 1.1
    effective_io_concurrency = 200
    
    # Logging
    log_destination = 'stderr'
    logging_collector = on
    log_directory = 'log'
    log_filename = 'postgresql-%a.log'
    log_rotation_age = 1d
    log_rotation_size = 100MB
    log_min_duration_statement = 1000
    log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
    
    # Performance monitoring
    track_activities = on
    track_counts = on
    track_io_timing = on
    track_functions = pl
    
    # Cost monitoring optimizations
    max_parallel_workers_per_gather = 2
    max_parallel_workers = 4
    seq_page_cost = 1.0

---
# PostgreSQL Initialization Scripts
apiVersion: v1
kind: ConfigMap
metadata:
  name: postgresql-init-scripts
  labels:
    app: cost-monitor
    component: database
data:
  01-init-schema.sh: |
    #!/bin/bash
    set -e
    
    echo "Creating cost_monitor database schema..."
    
    psql -v ON_ERROR_STOP=1 --username "$POSTGRESQL_USER" --dbname "$POSTGRESQL_DATABASE" <<-EOSQL
    
    -- Enable required extensions (skip pg_stat_statements if not superuser)
    CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
    
    -- Create providers table
    CREATE TABLE IF NOT EXISTS providers (
        id SERIAL PRIMARY KEY,
        name VARCHAR(50) UNIQUE NOT NULL,
        display_name VARCHAR(100) NOT NULL,
        is_enabled BOOLEAN DEFAULT TRUE,
        last_sync_at TIMESTAMP WITH TIME ZONE,
        sync_status VARCHAR(20) DEFAULT 'unknown',
        error_message TEXT,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
    );
    
    -- Insert default providers
    INSERT INTO providers (name, display_name) VALUES
    ('aws', 'Amazon Web Services'),
    ('azure', 'Microsoft Azure'),
    ('gcp', 'Google Cloud Platform')
    ON CONFLICT (name) DO NOTHING;

    -- Create AWS account names table for persistent account resolution
    CREATE TABLE IF NOT EXISTS aws_accounts (
        account_id VARCHAR(12) PRIMARY KEY,
        account_name VARCHAR(255) NOT NULL,
        is_management_account BOOLEAN DEFAULT FALSE,
        last_updated TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
        status VARCHAR(20) DEFAULT 'active',
        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
    );
    
    -- Create cost_data_points table with partitioning
    CREATE TABLE IF NOT EXISTS cost_data_points (
        id BIGSERIAL,
        provider_id INTEGER NOT NULL REFERENCES providers(id),
        date DATE NOT NULL,
        granularity VARCHAR(10) NOT NULL,
        cost DECIMAL(15,4) NOT NULL,
        currency VARCHAR(3) NOT NULL DEFAULT 'USD',
        service_name VARCHAR(255),
        account_id VARCHAR(100),
        account_name VARCHAR(255),
        region VARCHAR(50),
        provider_metadata JSONB,
        collected_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (id, date)
    ) PARTITION BY RANGE (date);
    
    -- Create partitions for current year and previous year (for historical data)
    DO \$\$
    DECLARE
        current_year INTEGER := EXTRACT('year' FROM CURRENT_DATE);
        partition_year INTEGER;
        start_date DATE;
        end_date DATE;
        partition_name TEXT;
    BEGIN
        -- Create partition for previous year (2025)
        partition_year := current_year - 1;
        start_date := DATE_TRUNC('year', MAKE_DATE(partition_year, 1, 1));
        end_date := start_date + INTERVAL '1 year';
        partition_name := 'cost_data_points_' || partition_year::TEXT;
        EXECUTE format(
            'CREATE TABLE IF NOT EXISTS %I PARTITION OF cost_data_points
             FOR VALUES FROM (%L) TO (%L)',
            partition_name, start_date, end_date
        );

        -- Create partition for current year (2026)
        partition_year := current_year;
        start_date := DATE_TRUNC('year', MAKE_DATE(partition_year, 1, 1));
        end_date := start_date + INTERVAL '1 year';
        partition_name := 'cost_data_points_' || partition_year::TEXT;
        EXECUTE format(
            'CREATE TABLE IF NOT EXISTS %I PARTITION OF cost_data_points
             FOR VALUES FROM (%L) TO (%L)',
            partition_name, start_date, end_date
        );

        -- Create partition for next year (2027) to handle early data
        partition_year := current_year + 1;
        start_date := DATE_TRUNC('year', MAKE_DATE(partition_year, 1, 1));
        end_date := start_date + INTERVAL '1 year';
        partition_name := 'cost_data_points_' || partition_year::TEXT;
        EXECUTE format(
            'CREATE TABLE IF NOT EXISTS %I PARTITION OF cost_data_points
             FOR VALUES FROM (%L) TO (%L)',
            partition_name, start_date, end_date
        );
    END\$\$;
    
    EOSQL
    
    echo "Database schema initialization completed."
  
  02-create-indexes.sh: |
    #!/bin/bash
    set -e
    
    echo "Creating database indexes..."
    
    psql -v ON_ERROR_STOP=1 --username "$POSTGRESQL_USER" --dbname "$POSTGRESQL_DATABASE" <<-EOSQL
    
    -- Create unique constraint for preventing duplicate cost data
    DO \$\$
    BEGIN
        -- Add unique constraint if it doesn't exist
        IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'unique_cost_data_point'
            AND conrelid = 'cost_data_points'::regclass
        ) THEN
            ALTER TABLE cost_data_points
            ADD CONSTRAINT unique_cost_data_point
            UNIQUE (provider_id, date, service_name, account_id, region);
        END IF;
    EXCEPTION
        WHEN others THEN
            -- Constraint might already exist, ignore error
            NULL;
    END\$\$;

    -- Create indexes for cost_data_points
    CREATE INDEX IF NOT EXISTS idx_cost_data_points_provider_date
    ON cost_data_points(provider_id, date DESC);

    CREATE INDEX IF NOT EXISTS idx_cost_data_points_date_granularity
    ON cost_data_points(date DESC, granularity);

    CREATE INDEX IF NOT EXISTS idx_cost_data_points_service
    ON cost_data_points(service_name, date DESC);

    CREATE INDEX IF NOT EXISTS idx_cost_data_points_collected_at
    ON cost_data_points(collected_at DESC);

    -- JSON indexes for provider metadata
    CREATE INDEX IF NOT EXISTS idx_cost_data_points_metadata_gin
    ON cost_data_points USING GIN(provider_metadata);

    -- Indexes for aws_accounts table
    CREATE INDEX IF NOT EXISTS idx_aws_accounts_updated
    ON aws_accounts(last_updated DESC);

    CREATE INDEX IF NOT EXISTS idx_aws_accounts_status
    ON aws_accounts(status, last_updated DESC);

    EOSQL
    
    echo "Index creation completed."
